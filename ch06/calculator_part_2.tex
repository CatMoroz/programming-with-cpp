% !TEX encoding   = UTF8
% !TEX spellcheck = ru_RU
% !TEX root = ../seminars.tex

%%============================
\chapter{Завершение программы}\label{chap:completingprog}
%%============================

%%===================
\section{Калькулятор}
%%===================
Для~упражнений нам необходим код программы <<калькулятор>>, версия~8 из~\textbookref{главы~7}. Исходный файл загрузите из~репозитория
\begin{center}
    \courserepo{projects/06/calculator08buggy.cpp}.
\end{center}

Исправьте все ошибки (как ошибки компиляции, так и логические ошибки), которые специально внедрены в~эту версию кода.



%%==================================
\section{Автоматизация тестирования}
%%==================================
\enquote{При~приведении исходного текста в~порядок можно непреднамеренно внести новые ошибки. После наведения порядка в~исходном тексте всегда следует проводить повторное тестирование кода. Ещё лучше проводить его после внесения каждого улучшения, так что, если что-то пойдёт неправильно, вы всегда сможете вспомнить, что именно вы сделали только что. Помните: тестировать надо пораньше и почаще.}\footcite[глава~7, страница~282, последний абзац]{Stroustrup:2016:ru}

Также в~учебнике упоминается, и мы полностью с~этим согласны, что \enquote{тестировать вручную, постоянно вводя одни и те же выражения по~много раз, очень утомительно и требует времени. А всё, что утомительно, рано или поздно приводит к~ошибкам}. Так что давайте поскорее познакомимся, как можно автоматизировать этот процесс и облегчить себе жизнь.



%%========================================
\paragraph{Подготовка тестовых выражений.}
%%========================================
Поместите ряд примеров в~отдельный файл. Назовите его, допустим, \code{test\_in.txt}. Будьте изобретательны, составляя тестовые выражения. Стремитесь <<сломать>> программу. Можете обменяться исполняемыми файлами с~товарищем и найти примеры, на~которых его калькулятор выдаст ошибку в~правильном выражении, <<упадёт>> или даже зависнет. Используйте эти данные для~проверки своей программы. Вспомните примеры, на~которых ваш калькулятор уже <<ломался>> раньше. Добавьте эти выражения. Вспомните про~обработку ошибок. Специально вставьте несколько ошибочных выражений. Добавьте абракадабру. Калькулятор должен корректно и с~этим справляться, выдавая разумные сообщения об~ошибках. Итак, мы получим нечто такое:

\begin{textcode*}{linenos=false}
0; 1; 2; 3; 4; 5; 6; 7; 8; 9;

1 + 2;  1+2;  1 + 2 + 3;
1 - 2;  1-2;  1 - 2 - 3;

1 * 2;  1*2;  1 * 2 * 3;
1 / 2;  1/2;  1 / 2 / 3;

1 + 2*3;  1 - 2*3;
1 + 2/3;  1 - 2/3;

...

flkj430478908ufn5649058s6767-4
;
@$#!$%%^*()*()LKLKGJ58-099545567/*~~~~())(-=43+4;

...

let t;
let = 2;
let let = t;

let + x;

quit
\end{textcode*}

Подумайте хорошенько, все ли допустимые операции и возможности вы проверили? Добавьте лишние пробелы, переходы на~новую строку, табуляции. И, наоборот, в~некоторых примерах слепите всё вместе, убрав все пробельные символы. Будьте дотошны и упорны. Лучше отловить ошибки самому, чем досаждать ими пользователю! Подходите к~вопросу тестирования серьёзно и со~всей ответственностью.



%%=========================================
\paragraph{Перенаправление ввода и вывода.}\label{par:inout}
%%=========================================
Командный интерпретатор, или командная оболочка, доступен как в~\name{Unix}, включая \name{Linux} и \name{MacOS}, так и в~\name{Windows}. Родной интерпретатор \code{cmd} в~последней гораздо беднее по~возможностям в~сравнении с~\code{shell} в~\name{Unix}-подобных системах. Тем не~менее, вместе с~\git{} поставляется \code{GitBash} "--- вариант интерпретатора \code{shell}. Подробнее о~возможностях \code{shell} изложено в~разделе на~станице \pageref{sect:shell}.

Подадим полученные тестовые выражения из~файла на~стандартный поток ввода нашему калькулятору. Эти приёмы работают и в~\code{cmd}.

\console`$ bin/calc < 06/test_in.txt`

\noindent Сообщения программы на~экране также можно перенаправить из~стандартного потока вывода в~файл:

\console`$ bin/calc < 06/test_in.txt > 06/test_out.txt`

Заметим, что не~весь вывод с~экрана попал в~файл. Сообщения об~ошибках по-прежнему остались на~экране. Так произошло, потому что вывод ошибок производится в~поток \code{cerr}, а не~в~\code{cout}. Поток вывода ошибок (дескриптор 2) обычно отделён от~простого потока вывода (дескриптор 1). Тем не~менее, мы можем легко направить этот поток в~тот же файл, связав оба потока вместе:

\console`$ bin/calc < 06/test_in.txt > 06/test_out.txt 2>&1`



%%=================================
\paragraph{Автоматизация процесса.}
%%=================================
Убедившись, что корректные выражения приводят к~правильным ответам, а некорректные вызывают разумные сообщения об~ошибках, сохраните ответы под~другим именем.

\console`$ mv 06/test_out.txt 06/test_ans.txt`

Теперь с~лёгкостью можно получить вывод результатов работы программы после внесения каких-либо изменений: улучшений, исправлений "--- и протестировать все те возможности, что уже отлажены и должны работать.

Перекомпилируйте код после внесения очередных изменений.

\console`$ g++ -o bin/calc -Ilib -pedantic -Wall -Wextra 06/calculator.cpp`

Запустите программу и подайте ей тестовый ввод.

\console`$ bin/calc < 06/test_in.txt > 06/test_out.txt 2>&1`

Сравните результаты программно. Для этого, в~\name{Unix}, воспользуйтесь командой \code{diff}.

\begin{consolecode}
$ diff -s 06/test_out.txt 06/test_ans.txt
Files test_out.txt and test_ans.txt are identical
\end{consolecode}

\noindent Под~\name{Windows} существует более простая команда \code{fc}.

\begin{consolecode}
$ fc /l 06/test_out.txt 06/test_ans.txt
Сравнение файлов test_out.txt и TEST_ANS.TXT
FC: различия не найдены
\end{consolecode}

Если файлы отличаются, значит либо что-то перестало работать после изменений, либо же обнаружилась ошибка в~предыдущих результатах.



%%================
\paragraph{P.\,S.}
%%================
Сравнивать файлы можно любой программой с~графическим интерфейсом или без~него. Среди известных нам утилит отметим:

\begin{itemize}
\item \code{cmp} и \code{diff} "--- простые и надёжные консольные программы, способные <<переваривать>> файлы большого объёма, доступны в~\code{shell} и \code{GitBash};
\item \code{fc} "--- аналог \code{cmp}, но под~\name{Windows};
\item \code{meld} "--- с~графическим пользовательским интерфейсом, под~\name{Linux};
\item \code{WinMerge} "--- также с~графикой, но под~\name{Windows}.
\end{itemize}

\noindent Проверьте, возможно, ваша \name{IDE} уже включает в~себя подобные средства.

Если вы используете систему контроля версий, то добавив результаты--ответы под~контроль версий, легко сравнивать с~прежней версией средствами самой этой системы. Например, это легко делается в~уже упомянутом ранее \name{Smartgit}-е.



%%================
\WhatToReadSection
%%================
\textcite{Stroustrup:2016:ru}: \textbf{глава~8}



%%===============
\ExercisesSection
%%===============
\begin{exercise}
\item Выполните упражнения из~\textbookref{главы~7} учебника.

\end{exercise}
