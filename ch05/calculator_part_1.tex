% !TEX encoding   = UTF8
% !TEX spellcheck = ru_RU
% !TEX root = ../seminars.tex

%%===========================
\chapter{Написание программы}
%%===========================

%%===================
\section{Калькулятор}
%%===================
Для~упражнений нам необходим код программы <<калькулятор>>, версия~2 из~\textbookref{главы~6}. Исходный файл загрузите из~репозитория
\begin{center}
  \courserepo{projects/05/calculator02buggy.cpp}.
\end{center}

Исправьте все ошибки (как ошибки компиляции, так и логические ошибки), которые специально внедрены в~эту версию кода.

Создайте файл \code{test\_in.txt}. Занесите туда все выражения, с~помощью которых вы тестировали работу вашей программы. Чуть позже мы покажем простой способ, как их подать на~вход программе непосредственно из~этого файла.

Используйте систему контроля версий (см.~раздел на~странице~\pageref{sect:git}) для~облегчения процесса разработки, ведения истории и создания разных ветвей кода, особенно, если они отличаются по~функциональным возможностям.



%%========================================
\section{Грамматика <<английского языка>>}
%%========================================
Напишем простую программу, проверяющую корректность предложений в~соответствии с~правилами <<английской грамматики>> из~\textbookref{главы~6}.

\cppfile[firstline=5, lastline=19]{projects/05/english_grammar.cpp}

Будем считать, что каждое предложение заканчивается точкой (\code{.}), окружённой пробельными символами. Например, фраза \code{birds fly but the fish swim .} является предложением, а фразы \code{birds fly but the fish swim} (пропущена точка) и \code{birds fly but the fish swim.} (перед точкой нет пробела) "--- нет. Для каждого введённого предложения программа должна просто отвечать <<OK>> или <<not OK>>.

Итак, где мы будем хранить наборы известных программе существительных, глаголов, союзов? Простой способ "--- использовать глобальные переменные типа \code{vector}.

\cppfile[firstline=30, lastline=32]{projects/05/english_grammar.cpp}

Сразу напишем вспомогательную функцию для~поиска в~каком-либо векторе заданного значения.

\cppfile[firstline=34, lastline=42]{projects/05/english_grammar.cpp}

Наша грамматика крайне простая, поэтому достаточно всего одной функции, которая будет пытаться прочитать предложение и возвращать \code{true} в~случае успеха. Напишем каркас и вернёмся к~ней немного позже.

\cppfile[firstline=44, lastline=46]{projects/05/english_grammar.cpp}
\cpp`  // ...`
\cppfile[firstline=67, lastline=68]{projects/05/english_grammar.cpp}

Пользователь может захотеть ввести несколько предложений. Чтобы дать ему такую возможность, нужен простой цикл, который будет вызывать \code{sentence()} и печатать результат проверки на~экран.

\cppfile[firstline=70]{projects/05/english_grammar.cpp}

Согласно нашей грамматике, предложение состоит из~существительного, за~которым следует глагол. На~языке программы это можно выразить так:

\cppfile[firstline=50, lastline=56]{projects/05/english_grammar.cpp}

Заметьте, что необходимо вначале проверить состояние потока, то есть проверить успешно ли считано следующее слово. И только затем уже проверять, содержится ли данное слово в~соответствующем векторе.

Далее, мы договорились, что предложение заканчивается точкой, окружённой пробелами для~простоты ввода. Или же за~ним следует союз. В~последнем случае, нам понадобится цикл для~чтения следующей части составного предложения.

\cppfile[firstline=48, lastline=49]{projects/05/english_grammar.cpp}
\cpp`    // ...`
\cppfile[firstline=58, lastline=66]{projects/05/english_grammar.cpp}

Первая версия завершена. Необходимо хорошенько её протестировать.

Далее добавьте артикль \textenglish{the} в~грамматику и доработайте программу. Также можно расширить словарный запас и внести другие улучшения по~вашему усмотрению.



%%=================================================
\section{Грамматика побитовых логических выражений}
%%=================================================
Побитовое логическое выражение напоминает арифметическое за~исключением того, что в~нём используются не~арифметические, а логические операторы: \cppinline{!}~(отрицание), \cppinline{~}~(дополнение), \cppinline{&}~(и), \cppinline{|}~(или) и \cppinline{^}~(исключающее или). Каждый оператор выполняет операции над~всеми битами своих целочисленных операндов. Операторы~\cppinline{!} и~\cppinline{~} являются префиксными унарными операторами. Оператор~\cppinline{^} имеет более высокий приоритет, чем оператор~\cppinline{|} (так же, как оператор~\cppinline{*} имеет более высокий приоритет, чем оператор~\cppinline{+}), так что выражение \cppinline{x|y^z} означает \cppinline{x|(y^z)}, а не~\cppinline{(x|y)^z}. Оператор~\cppinline{&} имеет более высокий приоритет, чем оператор~\cppinline{^}, так что выражение \cppinline{x^y&z} означает \cppinline{х^(y&z)}.

По~аналогии с~грамматикой обычных арифметических выражений, для логических побитовых выражений можно написать следующее:
\cppfile[firstline=14, lastline=29]{projects/05/bitwise_calculator.cpp}

Сделайте боковую ветку \code{bitwise-expr} в~системе контроля версий и переделайте код калькулятора так, чтобы он работал только с~целыми числами и вычислял значения побитовых логических выражений согласно разработанной грамматике.

Как убедиться, что ваша реализация работает правильно?



%%================
\WhatToReadSection
%%================
\textcite{Stroustrup:2016:ru}: \textbf{глава~7}



%%===============
\ExercisesSection
%%===============
\begin{exercise}
\item Выполните упражнения из~\textbookref{главы~6} учебника.
\end{exercise}
