% !TEX encoding   = UTF8
% !TEX spellcheck = ru_RU
% !TEX root = ../seminars.tex

%%================================
\chapter{Настройка ввода и вывода}
%%================================

%============================
\section{<<Переворот>> файла}
%============================
Рассмотрим упражнение~12 \textbookref{главы~11} учебника. Будем полагать, что файл может не~поместиться целиком в~оперативную память.

\cppfile[lastline=14]{projects/10/reverse_file.cpp}



%%===================================
\paragraph{Позиционирование в файле.}
%%===================================
Организуем считывание данных небольшими порциями по~\code{chunk} байтов из~начала файла (префикс \code{l} "--- left) и из~конца (префикс \code{r} "--- right) в~заготовленные буферы. Затем обратим порядок содержимого в~каждом буфере и запишем правый на~место левого, и наоборот "--- левый на~место правого. При~этом придётся управлять положением текущей позиции в~файле. Для~упрощения кода создадим два потока и откроем каждый для~доступа как на~чтение, так и на~запись одновременно.

\cppfile[firstline=16, lastline=54]{projects/10/reverse_file.cpp}

Контейнер \code{std::array} представляет собой обычный массив фиксированного размера. С~ним можно обращаться так же, как и с~динамическим массивом \code{std::vector}, т.\,е. доступны \code{size()}, \code{begin()}, \code{end()}, \code{empty()}, \code{[]}, \code{at()} и прочее, за~исключением методов меняющих размер.

\emph{Совет}: предпочитайте \code{std::array} взамен встроенных массивов в~стиле~\lang{C}.



%%==========================================
\paragraph{Аргументы функции \texttt{main}.}
%%==========================================
Вспомним, как мы запускаем какую-либо утилиту из~консоли и передаём ей аргументы, например:

\console`$ g++ -o bin/lsm -std=c++17 -pedantic -Wall -Wextra 02/least_squares.cpp`

\noindent \code{g++} "--- имя команды, а всё остальное "--- аргументы, которые ей передаёт пользователь. Если программа написана на~\code{C/C++}, то как она может получить эти аргументы? Для этого в~стандарте предусмотрен вариант функции \code{main} с~двумя аргументами:

\cppfile[firstline=56, lastline=56]{projects/10/reverse_file.cpp}

\noindent \code{argc} инициализируется количеством переданных аргументов. Имя команды является первым из~них и входит в~это число. А \code{argv} представляет собой массив значений.

Кто же вызывает \code{main} и передаёт ему эти аргументы? Среди звеньев цепочки, по~которой путешествуют наши аргументы, можно назвать сам командный интерпретатор и операционную систему, точнее, загрузчик на~исполнение.

Используя параметры командной строки, мы можем извлечь имена файлов и обратить порядок их содержимого в~теле функции \code{main}.

\cppfile[firstline=58, lastline=67]{projects/10/reverse_file.cpp}



%%======================
\paragraph{Тестирование}
%%======================
уже давно и прочно должно было войти в~привычку. Соберите исходный код в~исполнимый модуль

\console`$ g++ -o bin/reverse -std=c++14 -pedantic -Wall -Wextra 10/reverse_file.cpp`

\noindent и попробуйте <<сломать>> программку на~каких-нибудь входных данных. Вначале простые тесты, например:

\begin{consolecode}
$ echo "aaaaqbbbb" > 10/file.txt && bin/reverse 10/file.txt
$ cat 10/file.txt

bbbbqaaaa
\end{consolecode}

\noindent Команда \code{echo} просто печатает на~экран то, что ей передали. Далее, всё это перенаправляется с~экрана в~файл \code{file.txt}. Затем, обращается порядок и печатается на~экран новое содержимое файла при~помощи утилиты \code{cat}\footnote{Подробнее о~\name{Unix} утилитах, доступных в~\code{shell}, изложено в~Приложении на~странице \pageref{sect:utils}.}.

Заметьте, что \code{echo} добавила переход на~новую строку после выведенного текста, и теперь он оказался впереди. Рассмотрите разное количество символов, вплоть до~пустого файла: \code{"aqb"}, \code{"ab"}, \code{"a"}, \code{"}\code{"}. Убедившись, что всё работает, можно перейти к~исследованию варианта, когда размер файла больше порции, считываемой в~буфер за~один раз:

\console`$ bin/reverse 10/reverse_file.cpp 10/reverse_file.cpp`

\noindent Мы перевернули файл дважды и должны получить начальный вариант. Однако прежде, чем развлекаться с~исходным кодом, имеет смысл сохранить копию!

\console`$ cp 10/reverse_file.cpp 10/reverse_file_orig.cpp`

\noindent Фу-у-у-х! Теперь безопасно!

\begin{consolecode}
$ bin/reverse 10/reverse_file.cpp 10/reverse_file.cpp
$ diff -s 10/reverse_file.cpp 10/reverse_file_orig.cpp
Files 10/reverse_file.cpp and 10/reverse_file_orig.cpp are identical
\end{consolecode}



%%================
\WhatToReadSection
%%================
\textcite{Stroustrup:2016:ru}: \textbf{глава~12}



%%===============
\ExercisesSection
%%===============
\begin{exercise}
\item Выполните упражнения из~\textbookref{главы~11} учебника.

\end{exercise}
